import{W as g,mW as Jt,b as Xt,ak as zt,ck as Wt}from"./index-DKbcOXvO.js";import{r as te}from"./Program-HYRYH4Rq.js";import{h as ee}from"./LabelMetric-J5NAbP5i.js";import{i as ne}from"./ShaderBuilder-CRNP-Ry9.js";var Bt;(function(n){n[n.AnimatedMarker=0]="AnimatedMarker",n[n.Blend=1]="Blend",n[n.ComplexFill=2]="ComplexFill",n[n.ComplexOutlineFill=3]="ComplexOutlineFill",n[n.DotDensity=4]="DotDensity",n[n.Fill=5]="Fill",n[n.GradientFill=6]="GradientFill",n[n.GradientStroke=7]="GradientStroke",n[n.Grid=8]="Grid",n[n.Heatmap=9]="Heatmap",n[n.Label=10]="Label",n[n.Line=11]="Line",n[n.Magnifier=12]="Magnifier",n[n.Marker=13]="Marker",n[n.OutlineFill=14]="OutlineFill",n[n.Overlay=15]="Overlay",n[n.PatternFill=16]="PatternFill",n[n.PatternOutlineFill=17]="PatternOutlineFill",n[n.PieChart=18]="PieChart",n[n.Test=19]="Test",n[n.Text=20]="Text",n[n.TexturedLine=21]="TexturedLine",n[n.Bitmap=22]="Bitmap"})(Bt||(Bt={}));function re(n){return n.split(" ").map((t,e)=>e>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function ie(n,t){const e=[];for(e.push(t);e.length;){const r=e.pop();if(typeof r=="object"&&!n.has(r.uid)){n.add(r.uid);for(const i of r.children)e.push(i)}}}let C=class dt{constructor(){this.uid=dt.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=re(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof dt&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}};function c(n){return typeof n=="object"?n.clone():n}C.NodeCount=0;let y=class extends C{constructor(){super(...arguments),this.shaderType="primitive-node"}},se=class At extends C{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new At(c(this.child));return this.cloneInto(t),t}},oe=class Lt extends C{constructor(t,e,r){super(),this.property=t,this.target=e,this.returnType=r,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Lt(this.property,c(this.target),this.returnType);return this.cloneInto(t),t}};class Nt extends C{constructor(t,e,r,i){super(),this.x=t,this.y=e,this.target=r,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new Nt(this.x,this.y,c(this.target),this.returnType);return this.cloneInto(t),t}}class St extends C{constructor(t,e,r){super(),this.condition=t,this.ifTrue=e,this.ifFalse=r,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=c(this.ifTrue),e=this.ifFalse?c(this.ifFalse):null,r=new St(this.condition,t,e);return this.cloneInto(r),r}}let ce=class Gt extends C{constructor(t,e,r,i){super(),this.captureList=t,this.returnType=e,this.generator=i,this.shaderType="block-node",r&&(this.subgraph=new se(r))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const r in this.captureList)t[r]=c(this.captureList[r]);const e=new Gt(t,this.returnType,this.subgraph?c(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(e),e}},P=class Rt extends C{constructor(t,e,r,i,s,o=!1){super(),this.token=t,this._children=e,this.isInfix=r,this.isPropertyAccess=i,this.returnType=s,this.isTernary=o,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new Rt(this.token,this._children.map(c),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var G,ht,pt,lt,ft,yt,mt,gt,bt,wt,vt,xt,$t,_t;function ae(n){switch(n.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return $;case"float":case"vec2":case"vec3":case"vec4":return p;case"int":case"ivec2":case"ivec3":case"ivec4":return f;case"uint":case"uvec2":case"uvec3":case"uvec4":return H;default:throw new Error("Unable to handle type")}}function ue(n){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const e of t)if(e.includes(n))return e.map(r=>pe[r]);throw new Error("Unable to find type family")}function Ht(n){return new Proxy(n,{get(t,e){if(e==="constructor")return new Proxy(t.constructor,{construct:(r,i,s)=>Ht(new r(...i))});if(e in t)return t[e];if(typeof e=="string"){const r=ue(n.type);return x(n,e,r[e.length-1])}}})}function I(n){return new Proxy(n,{construct:(t,e,r)=>Ht(new t(...e))})}function de(n){return new Proxy(n,{get(t,e){if(e in t)return t[e];if(typeof e=="string"){const r=parseInt(e,10);if(!isNaN(r))return x(n,`[${r}]`,n.elementType.constructor)}}})}function he(n){return new Proxy(n,{construct:(t,e,r)=>de(new t(...e))})}let It=class extends Error{},J=G=class extends y{constructor(n,t){super(),this.elementType=n,this.size=t,this.children=[],this.type="array"}clone(){const n=new G(this.elementType,this.size);return super.cloneInto(n),n}get(n,t){const e=new f(n),r=t!=null?new f(t):null;return r!=null?ut(this,e,r,ae(this.elementType.constructor)):x(this,e,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(n,t,e){return ye(this,n,t,e)}glslFindIndex(n,t,e){return me(this,n,t,e)}static ofType(n,t){const e={construct:(r,i)=>new G(new n,t)};return new Proxy(G,e)}};J.type="array",J=G=g([he],J);class at extends y{constructor(t,e,r,i=!1){super(),this.elementType=t,this.xSize=e,this.ySize=r,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const t=new at(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,e){return this.isRowMajor?this._getRowMajor(t,e):this._getColumnMajor(t,e)}_getColumnMajor(t,e){const r=new f(t);return x(this,new f(e).add(r.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,e){const r=new f(t),i=new f(e);return x(this,r.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,e,r,i=!1){return new Proxy(J,{construct:(s,o)=>new at(new t,e,r,i)})}}at.type="array-2d";class Ct extends y{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const t=new Ct;return t.children=this.children.map(c),super.cloneInto(t),t}}Ct.type="sampler2D";let p=class E extends y{constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new E(c(this.children[0]));return super.cloneInto(t),t}multiply(t){return N(this,typeof t=="number"?m(t,E):t)}divide(t){return Q(this,typeof t=="number"?m(t,E):t)}add(t){return B(this,typeof t=="number"?m(t,E):t)}subtract(t){return Y(this,typeof t=="number"?m(t,E):t)}};p.type="float";let K=ht=class extends y{constructor(n,t){super(),this.type="vec2",this.children=[n,t].filter(e=>e!=null)}clone(){const n=new ht(c(this.children[0]),c(this.children[1]));return super.cloneInto(n),n}get 0(){return x(this,"[0]",p)}get 1(){return x(this,"[1]",p)}get 2(){throw new It}get 3(){throw new It}multiply(n){return N(this,typeof n=="number"?m(n,p):n)}divide(n){return Q(this,typeof n=="number"?m(n,p):n)}add(n){return B(this,typeof n=="number"?m(n,p):n)}subtract(n){return Y(this,typeof n=="number"?m(n,p):n)}};K.type="vec2",K=ht=g([I],K);let R=pt=class extends y{constructor(n,t,e){super(),this.type="vec3",this.children=[n,t,e].filter(r=>r!=null)}get 0(){return x(this,"[0]",p)}get 1(){return x(this,"[1]",p)}get 2(){return x(this,"[2]",p)}get 3(){throw new It}clone(){const n=new pt(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(n),n}multiply(n){return N(this,typeof n=="number"?m(n,p):n)}divide(n){return Q(this,typeof n=="number"?m(n,p):n)}add(n){return B(this,typeof n=="number"?m(n,p):n)}subtract(n){return Y(this,typeof n=="number"?m(n,p):n)}};R.type="vec3",R=pt=g([I],R);let k=lt=class extends y{constructor(n,t,e,r){super(),this.type="vec4",this.children=[n,t,e,r].filter(i=>i!=null)}clone(){const n=new lt(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(n),n}get 0(){return x(this,"[0]",p)}get 1(){return x(this,"[1]",p)}get 2(){return x(this,"[2]",p)}get 3(){return x(this,"[3]",p)}multiply(n){return N(this,typeof n=="number"?m(n,p):n)}divide(n){return Q(this,typeof n=="number"?m(n,p):n)}add(n){return B(this,typeof n=="number"?m(n,p):n)}subtract(n){return Y(this,typeof n=="number"?m(n,p):n)}};k.type="vec4",k=lt=g([I],k);let H=ft=class extends y{constructor(n){super(),this.type="uint",this.children=[n]}clone(){const n=new ft(c(this.children[0]));return super.cloneInto(n),n}};H.type="uint",H=ft=g([I],H);let X=yt=class extends y{constructor(n,t){super(),this.type="uvec2",this.children=[n,t].filter(e=>e!=null)}clone(){const n=new yt(c(this.children[0]),c(this.children[1]));return super.cloneInto(n),n}};X.type="uvec2",X=yt=g([I],X);let W=mt=class extends y{constructor(n,t,e){super(),this.type="uvec3",this.children=[n,t,e].filter(r=>r!=null)}clone(){const n=new mt(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(n),n}};W.type="uvec3",W=mt=g([I],W);let tt=gt=class extends y{constructor(n,t,e,r){super(),this.type="uvec4",this.children=[n,t,e,r].filter(i=>i!=null)}clone(){const n=new gt(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(n),n}};tt.type="uvec4",tt=gt=g([I],tt);class $ extends y{constructor(t){super(),this.type="bool",this.children=[t]}and(t){return ve(this,t)}or(t){return be(this,t)}clone(){const t=new $(c(this.children[0]));return super.cloneInto(t),t}}$.type="bool";let et=bt=class extends y{constructor(n,t){super(),this.type="bvec2",this.children=[n,t].filter(e=>e!=null)}all(){return kt(this)}any(){return Mt(this)}clone(){const n=new bt(c(this.children[0]),c(this.children[1]));return super.cloneInto(n),n}};et.type="bvec2",et=bt=g([I],et);let nt=wt=class extends y{constructor(n,t,e){super(),this.type="bvec3",this.children=[n,t,e].filter(r=>r!=null)}all(){return kt(this)}any(){return Mt(this)}clone(){const n=new wt(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(n),n}};function m(n,t){return typeof n=="number"?new t(n):n}nt.type="bvec3",nt=wt=g([I],nt);let rt=vt=class extends y{constructor(n,t,e,r){super(),this.type="bvec4",this.children=[n,t,e,r].filter(i=>i!=null)}all(){return kt(this)}any(){return Mt(this)}clone(){const n=new vt(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(n),n}};rt.type="bvec4",rt=vt=g([I],rt);class f extends y{constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return N(this,m(t,f))}add(t){return B(this,m(t,f))}subtract(t){return Y(this,m(t,f))}divide(t){return Q(this,m(t,f))}clone(){const t=new f(c(this.children[0]));return super.cloneInto(t),t}}f.type="int";let it=xt=class extends y{constructor(n,t){super(),this.type="ivec2",this.children=[n,t].filter(e=>e!=null)}clone(){const n=new xt(c(this.children[0]),c(this.children[1]));return super.cloneInto(n),n}};it.type="ivec2",it=xt=g([I],it);let st=$t=class extends y{constructor(n,t,e){super(),this.type="ivec3",this.children=[n,t,e].filter(r=>r!=null)}clone(){const n=new $t(c(this.children[0]),c(this.children[1]),c(this.children[2]));return super.cloneInto(n),n}};st.type="ivec3",st=$t=g([I],st);let ot=_t=class extends y{constructor(n,t,e,r){super(),this.type="ivec4",this.children=[n,t,e,r].filter(i=>i!=null)}clone(){const n=new _t(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(n),n}};ot.type="ivec4",ot=_t=g([I],ot);class Ft extends y{constructor(t,e,r,i){super(),this.type="mat2",this.children=[t,e,r,i]}clone(){const t=new Ft(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]));return super.cloneInto(t),t}get(t,e){return ut(this,new f(t),new f(e),p)}multiply(t){return N(this,t)}}Ft.type="mat2";class U extends y{static identity(){return new U(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const e=_e(t),r=$e(t);return new U(r,e,0,fe(e),r,0,0,0,1)}constructor(t,e,r,i,s,o,d,u,a){super(),this.type="mat3",this.children=[t,e,r,i,s,o,d,u,a]}add(t){return B(this,t)}multiply(t){return N(this,t)}get(t,e){return ut(this,new f(t),new f(e),p)}clone(){const t=new U(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]),c(this.children[4]),c(this.children[5]),c(this.children[6]),c(this.children[7]),c(this.children[8]));return super.cloneInto(t),t}}U.type="mat3";class q extends y{static identity(){return new q(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,e,r,i,s,o,d,u,a,h,l,w,F,j,D,Z){super(),this.type="mat4",this.children=[t,e,r,i,s,o,d,u,a,h,l,w,F,j,D,Z]}static fromColumns(t,e,r,i){return new q(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,r.x,r.y,r.z,r.w,i.x,i.y,i.z,i.w)}multiply(t){return N(this,t)}get(t,e){return ut(this,new f(t),new f(e),p)}clone(){const t=new q(c(this.children[0]),c(this.children[1]),c(this.children[2]),c(this.children[3]),c(this.children[4]),c(this.children[5]),c(this.children[6]),c(this.children[7]),c(this.children[8]),c(this.children[9]),c(this.children[10]),c(this.children[11]),c(this.children[12]),c(this.children[13]),c(this.children[14]),c(this.children[15]));return super.cloneInto(t),t}}q.type="mat4";const pe={float:p,vec2:K,vec3:R,vec4:k,int:f,ivec2:it,ivec3:st,ivec4:ot,uint:H,uvec2:X,uvec3:W,uvec4:tt,bool:$,bvec2:et,bvec3:nt,bvec4:rt},Ee=(...n)=>new f(...n),le=(...n)=>new p(...n),Ke=(...n)=>new K(...n),Ue=(...n)=>new R(...n),Oe=(...n)=>new k(...n),Be=(...n)=>new U(...n);function x(n,t,e){const r=new e(new oe(t,n,e));return r.isImplicit=!0,r}function ut(n,t,e,r){const i=new r(new Nt(t,e,n,r));return i.isImplicit=!0,i}function _(n,t,e,r=null){if(r){const s=new r,o=new r(new P(n,[t,e],!0,!1,s));return o.isImplicit=!0,o}if(t.type==="float"||t.type==="int"){const s=new e.constructor(new P(n,[t,e],!0,!1,e.constructor));return s.isImplicit=!0,s}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&e.type!=="float"){const s=new e.constructor(new P(n,[t,e],!0,!1,e.constructor));return s.isImplicit=!0,s}const i=new t.constructor(new P(n,[t,e],!0,!1,t.constructor));return i.isImplicit=!0,i}function v(n,t,e=t.constructor){const r=new e(new P(n,[t],!1,!1,e));return r.isImplicit=!0,r}function T(n,t,e,r=t.constructor){const i=new r(new P(n,[t,e],!1,!1,r));return i.isImplicit=!0,i}function Pt(n,t,e,r,i=t.constructor){const s=new i(new P(n,[t,e,r],!1,!1,i));return s.isImplicit=!0,s}function fe(n){return N(n,le(-1))}function qt(n,t,e,r){return new t(new ce(n,t,e,r))}function ye(n,t,e=0,r=n.size){const i=new f(e).setMutable().setDebugName("FindIndexIterator"),s=t(n.get(i)).setDebugName("FindIndexPredicate");return qt({iter:i},f,s,({out:d,iter:u,subgraph:a})=>`
${d} = -1;

for (; ${u} < ${r}; ${u}++) {

${a.body}

  if (${a.varName}) {
    ${d} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function me(n,t,e=0,r=n.size){return qt({array:n},f,null,({out:s,array:o})=>`
${s} = -1;
for (int i = ${e}; i < ${r}; i++) {
  bool condition;
  ${t({array:o,i:"i",out:"condition"})}
  if (condition) {
    ${s} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function ge(n,t,e){const r=typeof t=="function"?t():t,i=typeof e=="function"?e():e,s=new r.constructor(new St(n,r,i));return s.isImplicit=!0,s}function Ve(...n){const t=n.map(([d,u])=>typeof u=="function"?[d,u()]:[d,u]),e=t[0][1].constructor,r=t.findIndex(d=>d[0]===!0);if(r===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,r),s=t[r][1],o=new e(i.reduceRight((d,u)=>ge(u[0],u[1],d),s));return o.isImplicit=!0,o}function N(n,t){return _("*",n,t)}function Q(n,t){return _("/",n,t)}function B(n,t){return _("+",n,t)}function Y(n,t){return _("-",n,t)}function je(n,t){return _("%",n,t)}function De(n,t){return _(">>",n,t)}function ze(n,t){return _("&",n,t)}function Ae(n,t){return _("==",n,t,$)}function Le(n,t){return _("<",n,t,$)}function Ge(n,t){return _("<=",n,t,$)}function Re(n,t){return _(">",n,t,$)}function He(n,t){return _(">=",n,t,$)}function be(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>we(t,e),n[0])}function we(n,t){return _("||",n,t,$)}function ve(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>xe(t,e),n[0])}function xe(n,t){return _("&&",n,t,$)}function qe(n){return v("abs",n)}function kt(n){return v("all",n,$)}function Mt(n){return v("any",n,$)}function Qe(n,t){return t==null?v("atan",n):T("atan",n,t,n.constructor)}function Ye(n){return v("ceil",n)}function Ze(n,t,e){return Pt("clamp",n,t,e,n.constructor)}function $e(n){return v("cos",n)}function Je(n,t){return T("distance",n,t,p)}function Xe(n,t){return T("dot",n,t,p)}function We(n){return v("floor",n)}function tn(n){return v("fract",n)}function en(n){return v("length",n,p)}function nn(n,t){return T("max",n,t)}function rn(n,t){return T("min",n,t)}function sn(n,t,e){return Pt("mix",n,t,e)}function on(n,t){return T("mod",n,t)}function cn(n){return v("normalize",n)}function an(n){return n.type==="bool"?v("!",n):v("not",n)}function un(n,t){return T("pow",n,t)}function dn(n){return v("round",n)}function _e(n){return v("sin",n)}function hn(n,t,e){return Pt("smoothstep",n,t,e)}function pn(n){return v("sqrt",n)}function ln(n,t){return T("step",n,t,t.constructor)}function fn(n,t){return T("texture",n,t,k)}const z=5;function b(n,t,e){const r=t.split(`
`);for(const i of r)if(i.trim().length){{let s="";e!=null&&(s+=`/*id:${e??"000"}*/   `),n.body+=s.padEnd(14)}n.body+=" ".repeat(n.indent)+i+`
`}}class Vt{write(t){for(const e of t.rootOutputNodes())t.shouldPruneOutputNode(e)||(e.variableName=this._write(t,e.node));return t}_createVarName(t,e){let r="";return typeof e!="boolean"&&typeof e!="number"&&e.debugInfo.name&&(r=`${e.debugInfo.name}_`),`${r}v${t.varCount++}`}_write(t,e,r=!1){if(typeof e=="number"||typeof e=="boolean")return e.toString();let i=t.getEmit(e);if(i)return i;switch(e.shaderType){case"scope-node":i=this._writeScopeNode(t,e);break;case"primitive-node":i=this._writePrimitiveNode(t,e,r);break;case"function-node":i=this._writeFunctionNode(t,e);break;case"property-access-node":i=this._writePropertyAccessNode(t,e);break;case"property-access-2d-node":i=this._writePropertyAccess2DNode(t,e);break;case"text-node":i=e.text;break;case"block-node":i=this._writeBlockNode(t,e);break;case"condition-node":i=this._writeConditionNode(t,e)}return t.setEmit(e,i),i}_writeScopeNode(t,e){const r=new e.child.constructor;r.setDebugName(e.debugInfo.name);const i=this._write(t,r,!0);return b(t,`{ /*ScopeStart: ${e.uid} ${e.debugInfo.name}*/`),t.indent+=2,b(t,`${i} = ${this._write(t,e.child)};`),t.indent-=2,b(t,`} /*ScopeEnd: ${e.uid} ${e.debugInfo.name}*/`),i}_writeConditionNode(t,e){const r=new e.ifTrue.constructor,i=this._write(t,r,!0);b(t,`if (${this._write(t,e.condition)}) {`),t.indent+=2;const s=t.createSubgraphContext(),o=this._write(s,e.ifTrue);if(t.body+=s.body,o&&b(t,`${i} = ${o};`),t.indent-=2,b(t,"}"),e.ifFalse){b(t,"else {"),t.indent+=2;const d=t.createSubgraphContext(),u=this._write(d,e.ifFalse);t.body+=d.body,u&&b(t,`${i} = ${u};`),t.indent-=2,b(t,"}")}return i}_writeBlockNode(t,e){const{captureList:r,generator:i,returnType:s}=e,o={};for(const h in r){if(!r[h])continue;const l=this._write(t,r[h]);o[h]=l}const d=new s,u=this._write(t,d,!0);if(o.out=u,e.subgraph){const h=t.createSubgraphContext(),l=this._write(h,e.subgraph.child),w=h.body;o.subgraph={varName:l,body:w}}const a=i(o);return b(t,`{
`),t.indent+=2,b(t,a),t.indent-=2,b(t,`}
`),u}_writePropertyAccessNode(t,e){const r=this._write(t,e.target);return typeof e.property=="string"&&e.property.includes("[")?`${r}${e.property}`:typeof e.property!="string"?`${r}[${this._write(t,e.property)}]`:`${r}.${e.property}`}_writePropertyAccess2DNode(t,e){return`${this._write(t,e.target)}[${this._write(t,e.x)}][${this._write(t,e.y)}]`}_writeFunctionNode(t,e){const r=e.returnType.type;if(e.isInfix){const[o,d]=e.children.map(a=>this._write(t,a)),u=this._createVarName(t,e);return b(t,`${r.padEnd(z)} ${u} = ${o} ${e.token} ${d};`,e.uid),u}const i=e.children.map(o=>this._write(t,o)).join(", "),s=this._createVarName(t,e);return b(t,`${r.padEnd(z)} ${s} = ${e.token}(${i});`,e.uid),s}_writePrimitiveNode(t,e,r=!1){var a;const i=t.getInput(e);if(i)return i.isUsed=!0,i.variableName;const s=e.children.length===1&&((a=e.children[0])==null?void 0:a.type)===e.type;if(!e.isMutable&&(e.isImplicit||s))return this._write(t,e.children[0]);const o=this._createVarName(t,e);if(r)return b(t,`${e.type.padEnd(z)} ${o};`,e.uid),o;const d=!e.debugInfo.name&&!e.isMutable;if(d&&e.type==="float"&&typeof e.children[0]=="number")return Number.isInteger(e.children[0])?e.children[0].toFixed(1):e.children[0].toString();if(d&&e.type==="int"&&typeof e.children[0]=="number"&&Number.isInteger(e.children[0]))return e.children[0].toString();const u=e.children.map(h=>this._write(t,h)).join(", ");return e.type==="array"?(b(t,`${e.type.padEnd(z)} ${o} = [${u}];`,e.uid),o):d?`${e.type}(${u})`:(b(t,`${e.type.padEnd(z)} ${o} = ${e.type}(${u});`,e.uid),o)}}class S{constructor(t,e,r){this.variableName=t,this.variableInputType=e,this.node=r,this.type="shader-input",this.isUsed=!1}clone(){return new S(this.variableName,this.variableInputType,c(this.node))}}let M=class Qt{constructor(t,e,r){this.outVariableName=t,this.outVariableType=e,this.node=r,this.type="shader-output"}clone(){const t=new Qt(this.outVariableName,this.outVariableType,c(this.node));return t.variableName=this.variableName,t}};class O{static createVertex(t,e,r,i,s,o){const d=[];for(const a in t){const h=t[a],l=r.get(a);l?d.push(new S(l,"builtin",h)):d.push(new S("a_"+a,"in",h))}for(const a of i){const h=a.uniformHydrated;d.push(new S(a.uniformName,"uniform",h))}const u=[];for(const a in e){const h=e[a];a==="glPosition"?u.push(new M("gl_Position","builtin",h)):a==="glPointSize"?u.push(new M("gl_PointSize","builtin",h)):u.push(new M("v_"+a,"out",h))}return new O(d,u,s,o)}static createFragment(t,e,r,i,s,o){const d=[],u=Array.from(s.rootOutputNodes());for(const h in t){const l=t[h],w=r.get(h);if(w){d.push(new S(w,"builtin",l));continue}const F=u.find(j=>j.node===l);F&&d.push(new S(F.outVariableName,"in",l))}for(const h of i){const l=h.uniformHydrated;d.push(new S(h.uniformName,"uniform",l))}const a=[];for(const h in e){const l=e[h],w=r.get(h);h==="discard"?a.push(new M(null,"discard",l)):w?a.push(new M(w,"builtin",l)):a.push(new M(h,"out",l))}return new O(d,a,o)}constructor(t,e,r,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of t)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=e,this._transformFeedbackBindings=r,this._transformFeedbackNames=new Set(r.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,e){this._nodeEmitMap.set(t.uid,e)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const e of this._outputShaderTypes.values())t.push(e.node);for(;t.length;){const e=t.pop();typeof e!="number"&&typeof e!="boolean"&&t.push(...e.children.filter(Boolean)),yield e}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new O([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this.rootOutputNodes()){const r=e.outVariableType==="builtin";this.shouldPruneOutputNode(e)||(r?t.vertex.code.add(`// ${e.outVariableType.padEnd(7)} ${e.node.type.padEnd(9)} ${e.outVariableName};`):t.vertex.code.add(`${e.outVariableType.padEnd(10)} ${e.node.type.padEnd(9)} ${e.outVariableName};`))}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const e of this.rootOutputNodes())this.shouldPruneOutputNode(e)||t.vertex.code.add(`  ${e.outVariableName} = ${e.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let e=0;for(const r of this.rootOutputNodes())r.outVariableType==="builtin"?t.fragment.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):t.outputs.add(r.outVariableName,r.node.type,e++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())r.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${r.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.fragment.code.add("}")}_insertInputs(t,e){t[e].code.add("// INPUTS: "),t[e].code.add("// --------------------------------------------------------- ");for(const r of this.inputs())r.isUsed&&r.variableInputType!=="builtin"&&(r.node.type==="array"?t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}];`):r.node.type==="array-2d"?t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.variableName};`))}}const Ie=()=>zt.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function A(n,t,e){const r=t.length;if(r!==e){const i=new Xt("Invalid Uniform",`Invalid length, expected ${e} but got ${r}`,{uniformName:n,values:t});Ie().errorOnce(i)}}class jt{constructor(t,e,r,i,s,o){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=t,this.fragmentShader=e,this._locations=r,this._locationInfo=i,this._uniformBindings=s,this._transformFeedbackBindings=o}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const e=this._uniforms;if(!this._program){const i=new Map;for(const[o,d]of this._locations)i.set(o,d);const s=[];for(const o of this._transformFeedbackBindings??[]){const{index:d,propertyKey:u}=o;s[d]=`v_${u}`}this._program=new te(t,this.vertexShader,this.fragmentShader,i,new Map,s)}const r=this._program;t.useProgram(r);for(const i of this._uniformBindings){const{shaderModulePath:s,uniformName:o,uniformType:d,uniformArrayLength:u}=i,a=Jt(s,e);if(a==null){if(d==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${s}`)}switch(d==="array"||d==="array-2d"?i.uniformArrayElementType:d){case"sampler2D":{const{unit:h,texture:l}=a;if(r.setUniform1i(o,h),"type"in l)t.bindTexture(l,h);else{const w=ee(t,l.descriptor,l.data);t.bindTexture(w,h)}break}case"int":if(!u){r.setUniform1i(o,a);break}A(i.uniformName,a,u),r.setUniform1iv(o,a);break;case"float":if(!u){r.setUniform1f(o,a);break}A(i.uniformName,a,u),r.setUniform1fv(o,a);break;case"vec2":if(!u){r.setUniform2f(o,a[0],a[1]);break}A(i.uniformName,a,u),r.setUniform2fv(o,a.flat());break;case"vec3":if(!u){r.setUniform3f(o,a[0],a[1],a[2]);break}A(i.uniformName,a,u),r.setUniform3fv(o,a.flat());break;case"vec4":if(!u){r.setUniform4f(o,a[0],a[1],a[2],a[3]);break}A(i.uniformName,a,u),r.setUniform4fv(o,a.flat());break;case"mat3":r.setUniformMatrix3fv(o,a);break;case"mat4":r.setUniformMatrix4fv(o,a);break;default:throw new Error(`Unable to set uniform for type ${d}`)}}}}function L(n){return new n}function V(n,t,e){const r=n.constructor[t]??[];n.constructor.hasOwnProperty(t)||Object.defineProperty(n.constructor,t,{value:r.slice()}),n.constructor[t].push(e)}function yn(n,t){return(e,r)=>{V(e,"locations",{typeCtor:t,propertyKey:r,parameterIndex:null,index:n})}}const Te=n=>(t,e)=>{V(t,"builtins",{builtin:n,propertyKey:e})},mn=n=>(t,e,r)=>{V(t,"inputs",{inputCtor:n,propertyKey:e,parameterIndex:r})},gn=n=>(t,e)=>{V(t,"uniforms",{typeCtor:n,propertyKey:e})},bn=n=>(t,e)=>{V(t,"options",{typeCtor:n,propertyKey:e})},wn=(n,t)=>{V(n,"defines",{propertyKey:t})},Tt=(n,t)=>(e,r)=>{e.constructor.builtins.push({builtin:n,propertyKey:r,typeCtor:t})};class Dt{}Dt.builtins=[],g([Tt("gl_VertexID",f)],Dt.prototype,"glVertexID",void 0);class vn{}class ct{}ct.builtins=[],g([Tt("gl_FragCoord",k)],ct.prototype,"glFragCoord",void 0),g([Tt("gl_PointCoord",K)],ct.prototype,"glPointCoord",void 0);let Ne=class{};g([Te("gl_FragDepth")],Ne.prototype,"glFragDepth",void 0);class $n{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}let _n=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===0);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===1)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="fragment");if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){var t;return[...this.vertexInput.inputCtor.locations,...((t=this.computeInput)==null?void 0:t.inputCtor.locations)??[]]}get locationsMap(){const t=new Map,e=new Set;for(const r of this.locations)e.has(r.index)?zt.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:t}):(t.set(r.propertyKey,r.index),e.add(r.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([s,o])=>`${s}.${o}`).join("."),r=Wt(e),i=this.computeAttributes;this._locationInfo={hash:r,stringHash:e,locations:t,computeAttributeMap:i}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,i){try{const{vertex:s,fragment:o,uniformBindings:d}=this._generateShaders(t,e,r,i);return new jt(s,o,this.renamedLocationsMap,this.locationInfo,d,this.transformFeedbackBindings)}catch{return new jt("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(i=>i.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find(i=>i.propertyKey===t);if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,i){const s=Object.keys(t).map(a=>`${a}.${t[a]}`).join("."),o=Object.keys(r).map(a=>`${a}.${r[a]}`).join("."),d=Object.keys(i).map(a=>`${a}.${i[a]}`).join("."),u=Object.keys(e).filter(a=>this.optionPropertyKeys.has(a)&&e[a]).join(".");return`${this.constructor.name}.${s}.${o}.${d}.${u}`}_generateShaders(t,e,r,i){const s=[];this._setDefines(r),this._setOptionalUniforms(s,e),this._setRequiredUniforms(s);const o=this._hydrateVertexInput(i),d=this._injectPackPrecisionFactor(o,t),u=this._hydrateComputeInput(),a=u&&this._injectComputePackPrecisionFactor(u,t),h=this.vertex(d,a),l=this._hydrateFragmentInput(h),w=this.fragment(l),F=new Set;for(const Yt in w){const Zt=w[Yt];ie(F,Zt)}const j=this._getVertexInputBuiltins(),D=O.createVertex({...o,...u},h,j,s,this.transformFeedbackBindings,F);new Vt().write(D);const Z=this._getFragmentInputBuiltins(w);Z.set("glPointCoord","gl_PointCoord");const Et=O.createFragment(l,w,Z,s,D,this.transformFeedbackBindings);new Vt().write(Et);const Kt=this._createShaderBuilder(D,Et),Ut=Kt.generate("vertex"),Ot=Kt.generate("fragment");return this.logShader&&(console.log(Ut),console.log(Ot)),{vertex:Ut,fragment:Ot,uniformBindings:s}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options)e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new e.typeCtor;for(const i of r._uniforms??[]){const s=L(i.typeCtor),o=`u_${e.propertyKey}_${i.propertyKey}`,d=s.type,u=[e.propertyKey,i.propertyKey].join(".");if("type"in i.typeCtor&&i.typeCtor.type==="array"){const a=s;t.push({shaderModulePath:u,uniformName:o,uniformType:d,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:s})}else if("type"in i.typeCtor&&i.typeCtor.type==="array-2d"){const a=s;t.push({shaderModulePath:u,uniformName:o,uniformType:d,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:s})}else t.push({shaderModulePath:u,uniformName:o,uniformType:d,uniformHydrated:s});r[i.propertyKey]=s}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce((i,s)=>t[s.propertyKey]===!1?i:{...i,[s.propertyKey]:L(s.typeCtor)},{});for(const{propertyKey:i,typeCtor:s}of e.builtins){const o=L(s);r[i]=o}return r}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:L(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const r={};for(const i in t){const s=t[i],o=e[i];if(o){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[i]=s.divide(new p(o))}else r[i]=s}return r}_injectComputePackPrecisionFactor(t,e){const r={},i=new Map;for(const s in this.computeAttributes)for(const o of this.computeAttributes[s]??[])i.set(o,s);for(const s in t){const o=t[s],d=i.get(s);if(!d)continue;const u=e[d];if(u){if(o.type!=="float"&&o.type!=="vec2"&&o.type!=="vec3"&&o.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${o.type}`);r[s]=o.divide(new p(u))}else r[s]=o}return r}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:r,typeCtor:i}of ct.builtins){const s=L(i);e[r]=s}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:i}of t.builtins)e.set(i,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const i of e.builtins??[])r.set(i.propertyKey,i.builtin);return r}_createShaderBuilder(t,e){const r=new ne;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}};export{ve as $,hn as A,le as B,Dt as C,N as D,tn as E,on as F,We as G,Ue as H,Oe as I,Ke as J,wn as K,un as L,en as M,Ee as N,Ye as O,$n as P,bn as Q,vn as R,je as S,Ve as T,Ct as U,Je as V,f as W,R as X,k as Y,dn as Z,p as _,K as a,an as a0,cn as a1,J as a2,He as a3,be as a4,$ as a5,Be as a6,fe as a7,q as a8,qt as a9,Ft as aa,De as ab,ze as ac,jt as ad,fn as b,sn as c,Ae as d,Bt as e,Ze as f,gn as g,yn as h,qe as i,_n as j,rn as k,Ge as l,mn as m,Re as n,Le as o,Xe as p,nn as q,U as r,ln as s,Qe as t,pn as u,ct as v,Ne as w,$e as x,_e as y,ge as z};
