import{aJ as D,aG as L,kV as A,fL as N,g4 as B,fK as I,g0 as P,bg as v,kP as J,be as k,bj as z,jf as R,kS as H,bI as X,mS as G,bp as K}from"./index-DKbcOXvO.js";import{e as Q,o as V}from"./mat4f64-Dk4dwAN8.js";import{b as p,S as q,v as T}from"./sphere-BrZ4XJaF.js";import{s as F,e as w,i as f}from"./IntersectorInterfaces-BgX4KEwK.js";import"./boundedPlane-QV5Qhj1I.js";import{b as Y,d as $}from"./Geometry-Df3FWzDt.js";import{e as Z}from"./VertexAttribute-Cq4MnHjR.js";class tt{constructor(t,e,r){this.object=t,this.geometryId=e,this.triangleNr=r}}class et extends tt{constructor(t,e,r,s){super(t,e,r),this.center=s!=null?D(s):null}}class rt{constructor(t){this.layerUid=t}}let st=class extends rt{constructor(t,e){super(t),this.graphicUid=e}};function U(i){return(i==null?void 0:i.dist)!=null}const M=1e-5;class it{constructor(t){this.options=new F,this._results=new nt,this.transform=new Y,this.tolerance=M,this.verticalOffset=null,this._ray=p(),this._rayEnd=L(),this._rayBeginTransformed=L(),this._rayEndTransformed=L(),this.viewingMode=t??A.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,e,r){this.resetWithRay(q(t,e,this._ray),r)}resetWithRay(t,e){this.camera=e,t!==this._ray&&T(t,this._ray),this.options.verticalOffset!==0?this.viewingMode===A.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,N(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(t=null,e,r,s,n){var h;this.point=e,this.filterPredicate=s,this.tolerance=r??M;const o=$(this.verticalOffset);if(t&&t.length>0){const l=n?a=>{n(a)&&this.intersectObject(a)}:a=>{this.intersectObject(a)};for(const a of t){const u=(h=a.getSpatialQueryAccelerator)==null?void 0:h.call(a);u!=null?(o!=null?u.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,l,o):u.forEachAlongRay(this._ray.origin,this._ray.direction,l),this.options.selectionMode&&this.options.hud&&u.forEachDegenerateObject(l)):a.objects.forAll(d=>l(d))}}this.sortResults()}intersectObject(t){const e=t.geometries;if(!e)return;const r=t.effectiveTransformation,s=$(this.verticalOffset);for(const n of e){if(!n.visible)continue;const{material:o,id:h}=n;if(!o.visible)continue;this.transform.setAndInvalidateLazyTransforms(r,n.transformation),B(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),B(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const l=this.transform.transform;s!=null&&(s.objectTransform=this.transform),o.intersect(n,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(a,u,d,y,g,b)=>{if(a>=0){if(this.filterPredicate!=null&&!this.filterPredicate(this._ray.origin,this._rayEnd,a))return;const c=y?this._results.hud:this._results,x=y?m=>{const W=new et(t,h,d,b);m.set(f.HUD,W,a,u,V,g)}:m=>m.set(f.OBJECT,{object:t,geometryId:h,triangleNr:d},a,u,l,g);if((c.min.drapedLayerOrder==null||g>=c.min.drapedLayerOrder)&&(c.min.dist==null||a<c.min.dist)&&x(c.min),this.options.store!==w.MIN&&(c.max.drapedLayerOrder==null||g<c.max.drapedLayerOrder)&&(c.max.dist==null||a>c.max.dist)&&x(c.max),this.options.store===w.ALL)if(y){const m=new S(this._ray);x(m),this._results.hud.all.push(m)}else{const m=new O(this._ray);x(m),this._results.all.push(m)}}})}}sortResults(t=this._results.all){t.sort((e,r)=>e.dist!==r.dist?(e.dist??0)-(r.dist??0):e.drapedLayerOrder!==r.drapedLayerOrder?j(e.drapedLayerOrder,r.drapedLayerOrder):j(e.drapedLayerGraphicOrder,r.drapedLayerGraphicOrder))}}function j(i,t){return(t??-Number.MAX_VALUE)-(i??-Number.MAX_VALUE)}function pt(i){return new it(i)}class nt{constructor(){this.min=new O(p()),this.max=new O(p()),this.hud={min:new S(p()),max:new S(p()),all:new Array},this.ground=new O(p()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}class O{get ray(){return this._ray}get distanceInRenderSpace(){return this.dist!=null?(I(E,this.ray.direction,this.dist),P(E)):null}withinDistance(t){return!!U(this)&&this.distanceInRenderSpace<=t}getIntersectionPoint(t){return!!U(this)&&(I(E,this.ray.direction,this.dist),N(t,this.ray.origin,E),!0)}getTransformedNormal(t){return v(_,this.normal),_[3]=0,J(_,_,this.transformation),v(t,_),k(t,t)}constructor(t){this.intersector=f.OBJECT,this.normal=L(),this.transformation=Q(),this._ray=p(),this.init(t)}init(t){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=f.OBJECT,T(t,this._ray)}set(t,e,r,s,n,o,h){this.intersector=t,this.dist=r,v(this.normal,s??z),R(this.transformation,n??V),this.target=e,this.drapedLayerOrder=o,this.drapedLayerGraphicOrder=h}copy(t){T(t.ray,this._ray),this.intersector=t.intersector,this.dist=t.dist,this.target=t.target,this.drapedLayerOrder=t.drapedLayerOrder,this.drapedLayerGraphicOrder=t.drapedLayerGraphicOrder,v(this.normal,t.normal),R(this.transformation,t.transformation)}}class S extends O{constructor(){super(...arguments),this.intersector=f.HUD}}function at(i){return new O(i)}const E=L(),_=H();class ot extends st{constructor(t,e,r,s,n){super(t,e),this.layerUid=t,this.graphicUid=e,this.triangleNr=r,this.baseBoundingSphere=s,this.numLodLevels=n}}class ht{constructor(t,e,r,s){this.material=t,this.bufferWriter=t.createBufferWriter(),this.vertexBufferLayout=this.bufferWriter.vertexBufferLayout,this.buffer=e,this.elementCount=r,this.boundingInfo=s}get numTriangles(){return this.elementCount/3}get numVertices(){return this.elementCount}computeUsedMemory(){return this.buffer.byteLength+X}getRenderGeometry(){return this}intersect(t,e,r,s,n,o,h,l){const a=this.bufferWriter,u=this.buffer;a.intersect(u,t,r,s,(d,y,g,b,c)=>C(d,y,g,c,t,e,o,h,n,l))}}class Ot{constructor(t){this.engineGeometry=t}get material(){return this.engineGeometry.material}get numVertices(){return this.engineGeometry.attributes.get(Z.POSITION).indices.length}get numTriangles(){return this.engineGeometry.indexCount/3}get boundingInfo(){return this.engineGeometry.boundingInfo}computeUsedMemory(){return Array.from(this.engineGeometry.attributes.values()).reduce((t,e)=>t+K(e.data,e.indices),0)}getRenderGeometry(){const t=this.material,e=this.engineGeometry,r=e.attributes,s=e.boundingInfo,n=t.createBufferWriter(),o=n.vertexBufferLayout,h=n.elementCount(r),l=o.createBuffer(h);return n.write(null,null,r,null,l,0),new ht(t,l.buffer,h,s)}intersect(t,e,r,s,n,o,h,l){const a=this.engineGeometry;this.material.intersect(a,t.transform.transform,t,r,s,(u,d,y,g,b)=>C(u,d,y,b,t,e,o,h,n,l))}}function C(i,t,e,r,s,n,o,h,l,a){if(i<0||n&&!n(s.rayBegin,s.rayEnd,i))return;const u=new ot(o.layerUid,o.graphicUid(l),e,h,a);if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||i<s.results.min.dist)&&s.results.min.set(f.LOD,u,i,t,s.transform.transform,r),s.options.store!==w.MIN&&(s.results.max.drapedLayerOrder==null||r>=s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||i>s.results.max.dist)&&s.results.max.set(f.LOD,u,i,t,s.transform.transform,r),s.options.store===w.ALL){const d=at(s.results.min.ray);d.set(f.LOD,u,i,t,s.transform.transform,r),s.results.all.push(d)}}class _t{constructor(t,e=null){this.geometry=t,this.textures=e}get material(){return this.geometry.material}get numTriangles(){return this.geometry.numTriangles}}class Lt{constructor(t,e,r){this.components=t,this.minScreenSpaceRadius=e,this.pivotOffset=r;const s=G(this.components.map(n=>n.geometry));this.numVertices=s.reduce((n,o)=>n+o.numVertices,0)}}class bt{constructor(t){this.levels=t,this.levels.sort((e,r)=>e.minScreenSpaceRadius===r.minScreenSpaceRadius?e.numVertices-r.numVertices:e.minScreenSpaceRadius-r.minScreenSpaceRadius)}getMaterials(){const t=[];return this.levels.forEach(e=>e.components.forEach(r=>t.push(r.geometry.material))),G(t)}getTextures(){const t=new Array;return this.levels.forEach(e=>e.components.forEach(r=>{r.textures!=null&&t.push(...r.textures)})),G(t)}getGeometries(){const t=new Array;return this.levels.forEach(e=>e.components.forEach(r=>{t.push(r.geometry)})),G(t)}getEngineGeometries(){return this.getGeometries().map(t=>t.engineGeometry).filter(t=>t!=null)}computeUsedMemory(){const t=this.getGeometries(),e=this.getTextures(),r=t.reduce((s,n)=>s+n.computeUsedMemory(),0);return e.reduce((s,n)=>s+n.memoryEstimate,0)+r}}export{pt as T,Ot as a,Lt as f,bt as h,_t as l,ht as m};
